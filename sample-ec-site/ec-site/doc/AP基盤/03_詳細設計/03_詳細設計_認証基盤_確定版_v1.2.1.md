# 詳細設計書：AP基盤（認証・認可）【ドラフト】

- 文書名: 詳細設計書（認証・認可：AP基盤）
- 対象: AP基盤チーム（認証コンテキスト）
- 版数: 1.2.1（確定版）
- 更新日: 2026-01-25
- 参照: 基本設計 v0.8（02_基本設計_認証基盤_v0.8.md）, 要件定義 v1.0.2（01_要件定義_認証基盤_v1.0.2.md）

---

## 1. 目的

基本設計で定義した認証・認可機能について、実装可能な粒度（クラス/メソッド/SQL/設定/画面文言/例外）に落とし込み、UT/IT観点までトレース可能にする。

---

## 確定事項サマリ（v1.2.1）

- operatedBy：**loginId（= user_id）**
- LOGIN_SUCCESS監査：**既定OFF**（`auth.audit.login-success.enabled=false`）
- 絶対タイムアウトUX：**/login?reason=timeout へリダイレクト**（`MSG-SES-ERR-001`）
- HMACキー：**必要時のみローテ**（期間分割運用）
- H2互換VIEW：**DDL分離管理**

---


## 2. スコープ

- ログイン（成功/失敗、ロック、期限切れ、監査ログ）
- パスワード変更（本人）
- SharedService（業務チーム提供I/F）実装詳細
- DB（DDL/VIEW/索引、H2試験スキーマ方針）
- Spring Security設定詳細（Handler/Filter/Session/CSRF）

---

## 3. 決定事項（D-xx）一覧

基本設計付録Aの決定事項に対し、詳細設計で確定するための「決定内容」と、決定管理（状態/責任/期限/影響）を定義する。  
本章は、詳細設計における決定事項の一覧である（D-01〜D-10は決定済み）。

### 3.1 決定一覧（管理表）

| ID | 項目 | 決定内容 | 状態 | 決定責任 | 期限 | 影響範囲（主） |
|---|---|---|---|---|---|---|
| D-01 | 業務メニューURL | `auth.post-login-success-url` を必須（環境別） | 決定 | 業務チーム | 2026-01-25 | 成功遷移（UX/画面） |
| D-02 | LOGIN_SUCCESS監査ログ | default false（必要時true） | 決定 | 運用/セキュリティ | 2026-01-25 | ログ量/コスト |
| D-03 | NOT_FOUND loginId方式 | hmac（hex） | 決定 | セキュリティ | 2026-01-25 | 個人情報/監査 |
| D-04 | HMAC秘密鍵管理 | Secrets管理、年次ローテ | 決定 | 運用 | 2026-01-25 | 機密管理 |
| D-05 | ForwardedHeader対応 | LB配下はtrue | 決定 | インフラ | 2026-01-25 | IP記録/監査 |
| D-06 | 相関IDヘッダ | X-Correlation-Id、無ければ生成 | 決定 | AP基盤/インフラ | 2026-01-25 | トレーサビリティ |
| D-07 | bcrypt強度 | 10 | 決定 | セキュリティ/AP基盤 | 2026-01-25 | 認証性能 |
| D-08 | 絶対タイムアウト方式 | Filterでlogout→/login | 決定 | AP基盤 | 2026-01-25 | セッション/UX |
| D-09 | H2互換VIEW | H2専用DDLでrow_number版VIEW | 決定 | AP基盤 | 2026-01-25 | UT/CI安定 |
| D-10 | 管理者権限粒度 | ROLE_ADMIN必須（SharedServiceでチェック） | 決定 | 業務/セキュリティ | 2026-01-25 | 認可/操作範囲 |

### 3.2 決定手順（運用）

1. 提案（一次案）を基に、関係者（業務/運用/インフラ/セキュリティ）へレビュー依頼
2. 決定したら「状態」を `決定` に更新し、必要に応じて本文（該当章）へ反映
3. 反対・差戻しの場合、代替案と理由を追記し、再レビュー
4. 期限超過はリスクとしてエスカレーション（IT/運用/性能試験に 종속）

### 3.3 変更反映ルール

- 決定事項の変更は、変更理由・影響範囲・移行手順を明記し、変更履歴へ記録する。
- 設定値変更は 9章（環境差分表）と 10章（設定一覧）へ同時反映する。



## 4. 画面詳細設計

### 4.1 画面共通

- 文字コード: UTF-8
- 入力エラー表示: 項目直下（フィールドエラー）＋ページ上部（サマリ）を標準（業務標準に従う）
- CSRFトークン: formに埋め込み（Spring Security標準）
- メッセージ管理: メッセージID（MSG-xxx）＋リソース（properties）で管理

### 4.2 SCR-LOGIN（/login）

#### 4.2.1 レイアウト/項目
- login_id（name=`login_id`）
- password（name=`password`、type=password）

#### 4.2.2 入力チェック
- 必須のみ（形式/桁は業務側の実態に合わせて後続拡張可）
- エラー時は同画面でなく、要件に従い `/login/fail` へ遷移（FailureHandler）

#### 4.2.3 画面遷移
#### 4.2.4 タイムアウト表示（絶対タイムアウト）（決定：D-08）
- URLクエリ `timeout=absolute` の場合、以下メッセージを画面上部に表示する。
  - MSG-LOGIN-TIMEOUT-001: 「一定時間が経過したため、再度ログインしてください。」
- 表示はログイン失敗画面（/login/fail）ではなく、ログイン画面（/login）で行う（ユーザ行動として再ログインを促すため）。

- POST成功: SuccessHandlerへ
- POST失敗: `/login/fail`

### 4.3 SCR-LOGIN-FAIL（/login/fail）

#### 4.3.1 表示文言（確定候補）
- MSG-LOGIN-FAIL-001: 「ログインに失敗しました。入力内容を確認してください。」

> 内部理由（LOCKED等）は画面に出さない。

### 4.4 SCR-PWD-CHG（/account/password/change）

#### 4.4.1 項目
- currentPassword
- newPassword
- newPasswordConfirm

#### 4.4.2 入力チェック（サーバ側）
- currentPassword 必須・照合
- newPassword: 12文字以上、4種のうち3種以上、許可記号集合
- confirm一致
- 直近3世代一致禁止

### 4.5 SCR-PWD-CHG-COMP（/account/password/change/complete）
- 完了メッセージ（MSG-PWD-COMP-001）
- メニュー戻り導線（業務側URL）


### 4.6 メッセージ一覧（確定）

| メッセージID | 表示先 | 文言（確定候補） |
|---|---|---|
| MSG-LOGIN-FAIL-001 | /login/fail | ログインに失敗しました。入力内容を確認してください。 |
| MSG-LOGIN-TIMEOUT-001 | /login | 一定時間が経過したため、再度ログインしてください。 |
| MSG-PWD-COMP-001 | /account/password/change/complete | パスワードを変更しました。 |
| MSG-PWD-ERR-001 | /account/password/change | 現在のパスワードが正しくありません。 |
| MSG-PWD-ERR-002 | /account/password/change | 新しいパスワードがポリシーに違反しています。 |
| MSG-PWD-ERR-004 | /account/password/change | 新しいパスワードは過去に使用したものと同一です。 |

> 文言は業務側のUI標準（敬体/常体、改行、句読点）に合わせて最終調整する。


---

## 5. Spring Security 詳細設計

本章は、Spring Security による認証・セッション管理・ログ連携を、実装可能な粒度（クラス/メソッド/例外マッピング）で定義する。

### 5.1 SecurityConfig（SecurityFilterChain）

#### 5.1.1 設定値（プロパティ）参照
- プロパティ定義は **第9章「設定値一覧」** に集約する。
- 本節では、FilterChainに影響する主要プロパティのみ記載する。

- `auth.session.max-sessions`
- `auth.post-login-success-url`
- `auth.web.forwarded-header.enabled`
- `auth.web.correlation-id.header`
- `auth.web.correlation-id.generate-if-absent`
- `auth.session.absolute-timeout-hours`

#### 5.1.2 フィルタチェーン順序（概要）

| 順序 | Filter | 目的 |
|---:|---|---|
| 1 | `CorrelationIdFilter`（独自） | 相関IDの受入/生成、MDC設定 |
| 2 | `ForwardedHeaderFilter`（条件） | X-Forwarded-For/Proto/Host の解釈（LB配下） |
| 3 | `AbsoluteTimeoutFilter`（独自） | 絶対タイムアウト超過の強制ログアウト |
| 4 | Spring標準Filter群 | 認証/認可/CSRF/セッション |

> `ForwardedHeaderFilter` の有効化は `auth.web.forwarded-header.enabled` により切替する。

#### 5.1.3 設定クラス（詳細案）

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

  @Bean
  SecurityFilterChain filterChain(HttpSecurity http,
                                  CorrelationIdFilter correlationIdFilter,
                                  AbsoluteTimeoutFilter absoluteTimeoutFilter,
                                  AuthenticationSuccessHandler successHandler,
                                  AuthenticationFailureHandler failureHandler,
                                  @Value("${auth.session.max-sessions:1}") int maxSessions,
                                  @Value("${auth.web.forwarded-header.enabled:false}") boolean forwardedEnabled) throws Exception {

    if (forwardedEnabled) {
      http.addFilterBefore(new ForwardedHeaderFilter(), ChannelProcessingFilter.class);
    }
    http.addFilterBefore(correlationIdFilter, ChannelProcessingFilter.class);
    http.addFilterAfter(absoluteTimeoutFilter, CorrelationIdFilter.class);

    http
      .csrf(csrf -> csrf.enable())
      .authorizeHttpRequests(auth -> auth
        .requestMatchers("/login", "/login/**").permitAll()
        .requestMatchers("/account/password/**").authenticated()
        .anyRequest().authenticated()
      )
      .formLogin(form -> form
        .loginPage("/login")
        .loginProcessingUrl("/login")
        .usernameParameter("login_id")
        .passwordParameter("password")
        .successHandler(successHandler)
        .failureHandler(failureHandler)
        .permitAll()
      )
      .sessionManagement(sess -> sess
        .sessionFixation(sessionFixation -> sessionFixation.migrateSession())
        .maximumSessions(maxSessions)
        .maxSessionsPreventsLogin(false)
      )
      .logout(logout -> logout
        .logoutUrl("/logout")
        .logoutSuccessUrl("/login")
        .invalidateHttpSession(true)
        .deleteCookies("JSESSIONID")
      );

    return http.build();
  }
}
```

### 5.2 CorrelationIdFilter（新規）

#### 5.2.1 仕様
- 受入/返却ヘッダ名: `X-Correlation-Id`（固定）
- 入力: リクエストヘッダ（`auth.web.correlation-id.header`）
- 出力:
  - MDC（キー: `correlationId`）
  - レスポンスヘッダへ同名で返却
- 生成:
  - ヘッダが無い/空の場合、`auth.web.correlation-id.generate-if-absent=true` なら UUIDv4 を生成

#### 5.2.2 擬似コード

```java
public class CorrelationIdFilter extends OncePerRequestFilter {

  private final String headerName;
  private final boolean generateIfAbsent;

  @Override
  protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain) {
    String cid = req.getHeader(headerName);
    if ((cid == null || cid.isBlank()) && generateIfAbsent) {
      cid = UUID.randomUUID().toString();
    }
    if (cid != null && !cid.isBlank()) {
      MDC.put("correlationId", cid);
      res.setHeader(headerName, cid);
    }
    try {
      chain.doFilter(req, res);
    } finally {
      MDC.remove("correlationId");
    }
  }
}
```

### 5.3 AbsoluteTimeoutFilter（新規）

#### 5.3.1 仕様
- セッション属性 `AUTH_SESSION_CREATED_AT`（Instant）を保持し、未設定なら初回リクエストで設定する。
- `now - createdAt > auth.session.absolute-timeout-hours` の場合、以下を実施する。
  1. `SecurityContextLogoutHandler` によりログアウト（SecurityContext/Session破棄）
  2. 画面系: `/login?timeout=absolute` へリダイレクト

> REST/APIの場合は 401 を返すなど別挙動が必要だが、本スコープでは画面系のみを対象とする。

#### 5.3.2 擬似コード
#### 5.3.3 適用除外（推奨）
- `/login` および `/login/**`、静的リソース（`/css/**` `/js/**` `/images/**` 等）は適用除外とする。
- 除外しない場合、リダイレクトループの原因となるため注意する。

#### 5.3.4 UX（決定：D-08）
- 絶対タイムアウト超過時は、強制ログアウト後に **`/login?timeout=absolute`** へリダイレクトする。
- 画面側は `timeout=absolute` を検知し、MSG-LOGIN-TIMEOUT-001 を表示する。


```java
public class AbsoluteTimeoutFilter extends OncePerRequestFilter {

  private static final String KEY = "AUTH_SESSION_CREATED_AT";
  private final Duration absoluteTimeout;

  @Override
  protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain) {
    HttpSession session = req.getSession(false);
    if (session != null) {
      Instant createdAt = (Instant) session.getAttribute(KEY);
      if (createdAt == null) {
        session.setAttribute(KEY, Instant.now());
      } else if (Instant.now().isAfter(createdAt.plus(absoluteTimeout))) {
        new SecurityContextLogoutHandler().logout(req, res, SecurityContextHolder.getContext().getAuthentication());
        res.sendRedirect(req.getContextPath() + "/login?timeout=absolute");
        return;
      }
    }
    chain.doFilter(req, res);
  }
}
```

### 5.4 SuccessHandler（AuthAuthenticationSuccessHandler）
- `auth.post-login-success-url` は **必須** とし、`/` から始まるアプリ内パス（例: `/menu`）を設定する（決定：D-01）。


#### 5.4.1 仕様
- 入力: Authentication（principalに authAccountId を保持する）
- 処理:
  1. `LoginProcessSharedService.onLoginSuccess(authAccountId)`
  2. `PasswordChangeRequiredService.isRequired(authAccountId)` で変更必須判定
  3. 必須なら `/account/password/change`、それ以外は `auth.post-login-success-url` へリダイレクト
- 出力: リダイレクト

#### 5.4.2 擬似コード

```java
public class AuthAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

  private final LoginProcessSharedService loginProcess;
  private final PasswordChangeRequiredService pwRequired;
  private final String postLoginUrl;

  @Override
  public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication auth) {
    Long authAccountId = ((AuthPrincipal) auth.getPrincipal()).authAccountId();
    loginProcess.onLoginSuccess(authAccountId);

    if (pwRequired.isRequired(authAccountId)) {
      res.sendRedirect(req.getContextPath() + "/account/password/change");
    } else {
      res.sendRedirect(req.getContextPath() + postLoginUrl);
    }
  }
}
```

### 5.5 FailureHandler（AuthAuthenticationFailureHandler）

#### 5.5.1 例外→失敗理由マッピング（確定）

| 例外/状態 | LoginFailureReason | 補足 |
|---|---|---|
| BadCredentialsException | FAILURE | 失敗カウント対象 |
| LockedException | LOCKED | カウント対象外 |
| DisabledException | DISABLED | カウント対象外 |
| AccountExpiredException | EXPIRED | カウント対象外、EXPIRE履歴登録（冪等） |
| UsernameNotFoundException | NOT_FOUND | DB履歴なし、監査ログのみ |
| InternalAuthenticationServiceException（notFound隠蔽） | NOT_FOUND | UsernameNotFound隠蔽目的 |

#### 5.5.2 NOT_FOUND の隠蔽（推奨）
- `DaoAuthenticationProvider` はデフォルトで `UsernameNotFoundException` を隠蔽できる（`hideUserNotFoundExceptions=true`）。
- **推奨**: hideUserNotFoundExceptions を有効にし、外部へ例外差分を漏らさない。
- ただし監査ログでは NOT_FOUND を判別して記録する必要があるため、UserDetailsService側で「見つからない場合に監査対象情報（loginId）」を一時保持する方式を採用する。

方式案（確定候補）:
- `LoginAttemptContext`（ThreadLocal）に、入力 loginId と notFound フラグを保持し、FailureHandlerで参照して onLoginAttemptNotFound を呼ぶ。

#### 5.5.3 擬似コード（概要）

```java
public class AuthAuthenticationFailureHandler implements AuthenticationFailureHandler {

  private final LoginProcessSharedService loginProcess;

  @Override
  public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException ex) {

    // not found 判定（ThreadLocal経由）
    if (LoginAttemptContext.isNotFound()) {
      loginProcess.onLoginAttemptNotFound(LoginAttemptContext.loginId());
      res.sendRedirect(req.getContextPath() + "/login/fail");
      return;
    }

    Long authAccountId = LoginAttemptContext.authAccountId(); // loadUserで設定（存在時）
    LoginFailureReason reason = map(ex);
    loginProcess.onLoginFailure(authAccountId, reason);
    res.sendRedirect(req.getContextPath() + "/login/fail");
  }
}
```

> `LoginAttemptContext` のスコープ管理（finallyで必ずclear）を行い、スレッド再利用による漏えいを防止する。

### 5.6 UserDetails（principal）設計

- principal: `AuthPrincipal`（値オブジェクト的に扱う）
  - `authAccountId`
  - `loginId`
  - `authorities`（role_code→ROLE_付与）

---

## 6. SharedService 実装詳細

本章は、業務チームへ提供する SharedService（Application層）の実装仕様を定義する。  
トランザクション境界、認可、例外変換、冪等制御、履歴insertの順序を明確にする。

### 6.1 共通方針

#### 6.1.1 トランザクション
- Command/Usecase: `@Transactional`（REQUIRED）
- Query: `@Transactional(readOnly=true)`
- 履歴insertは、原則として同一Tx内で実施する（整合性優先）

#### 6.1.2 例外変換（Infrastructure → Application）
- MyBatis/DB例外（重複キー等）は `ConflictException`
- 対象不在は `NotFoundException`
- 入力不備は `ValidationException`
- ポリシー違反は `PolicyViolationException`
- 権限不足は `PermissionDeniedException`

#### 6.1.3 監査ログ
- 監査ログ出力は SharedService 側で最終確定とし、Handler側では最小限（呼び出し）に留める。
- `operatedBy` は ContextSharedService（ログイン中）から取得する。

### 6.2 管理者操作の認可（AuthAccountAdminSharedService）

#### 6.2.1 権限制御
- D-10一次案に従い、`ROLE_ADMIN` を必須とする。
- 実現方式（確定候補）: `@PreAuthorize("hasRole('ADMIN')")`
  - 併せて、メソッド内でも `ContextSharedService.currentRoleCodes()` を参照し防御的チェックを行う（任意）。

#### 6.2.2 operated_by
- 管理者操作は必ず `operated_by` を履歴へ記録する。
- 取得: `AuthAccountContextSharedService.currentAuthAccountId()` を利用する。

### 6.3 LoginProcessSharedService（認証イベント処理）

#### 6.3.1 シグネチャ（再掲）

```java
public enum LoginFailureReason {
  FAILURE, LOCKED, DISABLED, DELETED, EXPIRED
}

public interface LoginProcessSharedService {
  void onLoginSuccess(Long authAccountId);
  void onLoginFailure(Long authAccountId, LoginFailureReason reason);
  void onLoginAttemptNotFound(String loginId); // 監査ログのみ
}
```

#### 6.3.2 onLoginSuccess の処理仕様（順序）

1. `AUTH_LOGIN_HISTORY` に `result=SUCCESS` を insert
2. 監査ログ `LOGIN_SUCCESS` を出力（`auth.audit.success.enabled=true` の場合）
3. 返却（例外時はRuntimeで上位へ）

> `LOGIN_SUCCESS` の監査ログ出力は決定（D-02）。DB履歴は必ず登録する。

#### 6.3.3 onLoginFailure の処理仕様（順序）

入力:
- authAccountId（存在すること）
- reason（FAILURE/LOCKED/DISABLED/DELETED/EXPIRED）

処理順序:
1. `AUTH_LOGIN_HISTORY` に `result=reason` を insert
2. reason=FAILURE の場合のみ、連続失敗回数を算出し、閾値到達なら LOCK登録（冪等）
3. reason=EXPIRED の場合、EXPIRE履歴を登録（冪等）
4. 監査ログ `LOGIN_FAILURE` を出力（reason含む）

#### 6.3.4 連続失敗回数算出（FAILUREのみ）

- 定義: 「直近の SUCCESS が出現するまでの連続 FAILURE 件数」
- SQL案: 最新から順に一定件数を取得し、SUCCESSが現れるまでカウント
  - 性能のため、上限N（例: 20件）を設ける（詳細設計で確定）
- 閾値到達時:
  - `AUTH_ACCOUNT_LOCK_HISTORY` に LOCK（locked=true）を insert（冪等）
  - 次回以降は locked として拒否（LOCKED）

#### 6.3.5 LOCK登録の冪等制御（確定候補）

- 最新ロック状態を取得し、既に locked=true なら insert しない。
- insertする場合は occurred_at=now、operated_by=NULL（システム）を許容。

疑似SQL:
```sql
-- latest lock state
SELECT locked FROM AUTH_ACCOUNT_LOCK_HISTORY
WHERE auth_account_id = ?
ORDER BY occurred_at DESC, auth_account_lock_history_id DESC
LIMIT 1;

-- if not locked then insert locked=true
INSERT INTO AUTH_ACCOUNT_LOCK_HISTORY(auth_account_id, locked, occurred_at, operated_by)
VALUES(?, true, now(), null);
```

#### 6.3.6 EXPIRE登録の冪等制御（確定候補）

- 最新期限イベントを取得し、最新が EXPIRE なら insert しない。
- insertする場合は occurred_at=now。

疑似SQL:
```sql
SELECT event_type FROM AUTH_ACCOUNT_EXPIRY_HISTORY
WHERE auth_account_id = ?
ORDER BY occurred_at DESC, auth_account_expiry_history_id DESC
LIMIT 1;

INSERT INTO AUTH_ACCOUNT_EXPIRY_HISTORY(auth_account_id, event_type, occurred_at, operated_by)
VALUES(?, 'EXPIRE', now(), null);
```

#### 6.3.7 onLoginAttemptNotFound の処理

- DB履歴へは **記録しない**
- 監査ログ `LOGIN_ATTEMPT_NOT_FOUND` を出力
  - loginIdは `auth.audit.loginId.mode` に従い mask/hmac する（D-03確定後に反映）

### 6.4 PasswordChangeSharedService（本人変更）

#### 6.4.1 changePassword(authAccountId, currentPassword, newPassword, confirmPassword)

- 目的: 本人によるパスワード変更（変更完了で期限切れ解除）
- 入力:
  - `authAccountId`: セッションから取得（画面入力不可）
  - `currentPassword`: 現在パスワード（平文）
  - `newPassword`: 新パスワード（平文）
  - `confirmPassword`: 確認用（平文）

- 処理フロー:
  1. `newPassword` と `confirmPassword` が一致しない場合は `PasswordConfirmMismatchException`（MSG-PWD-ERR-003）
  2. `AUTH_ACCOUNT.password_hash` を取得し、`currentPassword` を bcrypt で照合。不一致は `InvalidCurrentPasswordException`（MSG-PWD-ERR-001）
  3. `AUTH_ACCOUNT.login_id` を取得し、PasswordPolicy を実行（6.4.2）。違反は `PasswordPolicyViolationException`（MSG-PWD-ERR-002）
  4. パスワード履歴（過去N世代）との一致禁止（`auth.password.history-count`）。一致なら `PasswordReusedException`（MSG-PWD-ERR-002）
  5. `AUTH_ACCOUNT.password_hash` を更新（bcrypt）
  6. `AUTH_PASSWORD_HISTORY` insert（`CHANGE_SELF`）
  7. 期限解除: `AUTH_ACCOUNT_EXPIRY_HISTORY` に `UNEXPIRE` insert（理由 `PASSWORD_CHANGED`、冪等）
  8. 監査ログ: `PASSWORD_CHANGED`

- トランザクション:
  - Application層で単一Tx（更新＋履歴＋期限解除までを原子化）

#### 6.4.2 PasswordPolicy（確定）

- 長さ:
  - `auth.password.min-length`（default 12）
  - `auth.password.max-length`（default 64）
- 許可文字:
  - ASCII printable（0x21-0x7E）※空白不可
- 構成要件:
  - 英字1以上（`auth.password.require-alpha`）
  - 数字1以上（`auth.password.require-digit`）
- 禁止:
  - loginId 含有（`auth.password.prohibit-include-login-id`）
    - 大文字小文字/記号差を無視した正規化（英数字のみ抽出→小文字化）で包含判定
  - 連番（単調増加/減少）3文字以上（`auth.password.prohibit-seq-length`）
  - 同一文字4連続以上（`auth.password.prohibit-repeat-length`）

### 6.5 AuthAccountAdminSharedService（管理者）

- 目的: 管理者によるアカウント管理（作成/初期化/ロック解除/期限解除/状態変更/ロール変更）
- 認可: `@PreAuthorize("hasRole('ADMIN')")`（D-10）
- 監査: すべての操作は監査ログ出力対象（第8章）

#### 6.5.1 createAccount(loginId, roleCodes, operatedBy)

- 処理:
  1. loginId重複チェック（`existsLoginId`、競合時は `DuplicateLoginIdException`）
  2. `AUTH_ACCOUNT` insert（初期PWハッシュ: `auth.initial-password-hash`、`account_status=ACTIVE`）
  3. `AUTH_PASSWORD_HISTORY` insert（`INITIAL`）
  4. 期限付与: `AUTH_ACCOUNT_EXPIRY_HISTORY` に `EXPIRE` insert（理由 `INITIAL`、冪等）
  5. `AUTH_ACCOUNT_ROLE` を roleCodes 分付与（role_code→role_id 解決。存在しない場合は `RoleNotFoundException`）
  6. 監査ログ: `ADMIN_CREATE_ACCOUNT`（loginIdはHMAC化して出力）

- 例外（API層でコード化）:
  - 重複: `DuplicateLoginIdException` → `ADMIN-BIZ-001`（409）
  - ロール不正: `RoleNotFoundException` → `ADMIN-BIZ-002`（400）

#### 6.5.2 resetPasswordToInitial(authAccountId, operatedBy)

- 処理:
  1. `AUTH_ACCOUNT.password_hash` を初期PWハッシュへ更新
  2. `AUTH_PASSWORD_HISTORY` insert（`ADMIN_RESET`）
  3. 期限付与: `AUTH_ACCOUNT_EXPIRY_HISTORY` に `EXPIRE` insert（理由 `ADMIN_RESET`、冪等）
  4. 監査ログ: `ADMIN_RESET_PASSWORD`

#### 6.5.3 unlock(authAccountId, operatedBy)

- 処理:
  - `AUTH_ACCOUNT_LOCK_HISTORY` に `locked=false` を insert（理由 `ADMIN_UNLOCK`、冪等）
  - 監査ログ: `ADMIN_UNLOCK`

#### 6.5.4 unexpire(authAccountId, operatedBy)

- 処理:
  - `AUTH_ACCOUNT_EXPIRY_HISTORY` に `UNEXPIRE` を insert（理由 `ADMIN_UNEXPIRE`、冪等）
  - 監査ログ: `ADMIN_UNEXPIRE`

#### 6.5.5 disable/enable/delete(authAccountId, reason, operatedBy)

- 処理:
  1. `AUTH_ACCOUNT.account_status` を更新（`DISABLED`/`ACTIVE`/`DELETED`）
  2. `AUTH_ACCOUNT_STATUS_HISTORY` insert（from/to/reason）
  3. 監査ログ: `ADMIN_STATUS_CHANGE`（fromStatus/toStatus/reason/operatedBy）

#### 6.5.6 replaceRoles(authAccountId, roleCodes, operatedBy)

- 処理:
  1. 既存 `AUTH_ACCOUNT_ROLE` を削除
  2. roleCodes 分を付与（role_code→role_id 解決。不正は例外）
  3. 監査ログ: `ADMIN_REPLACE_ROLES`

### 6.6 QuerySharedService（参照）

- `AUTH_ACCOUNT_CURRENT_V` と `AUTH_ACCOUNT_ROLE_V` を活用してN+1を回避する。
- `search(loginIdPrefix, accountStatus, limit, offset)` は以下の2段階取得を基本とする。
  1. CURRENT_V から対象アカウント一覧を取得
  2. ROLE_V を `IN (auth_account_id...)` で一括取得し、DTOへ集約

---


### 6.7 管理者API（Presentation: AdminAuthAccountController）

- 目的: 業務チームが管理者操作を呼び出すためのAPI入口（UIは業務側で実装可）
- URLプレフィックス: `/admin/auth/accounts`
- 認可: SharedService境界で `ROLE_ADMIN` を必須（D-10）
- 入力バリデーション: `@Valid`（Jakarta Validation）
- 例外→エラーコード: `AdminApiExceptionHandler` で統一（6.7.2）

#### 6.7.1 エンドポイント一覧

| No | Method | Path | Request | Response | 監査イベント |
|---:|---|---|---|---|---|
| 1 | POST | `/admin/auth/accounts` | `AdminCreateAccountRequest` | 201 `AdminCreateAccountResponse` | `ADMIN_CREATE_ACCOUNT` |
| 2 | POST | `/admin/auth/accounts/{id}/password/reset` | `AdminOperatedByRequest` | 200 | `ADMIN_RESET_PASSWORD` |
| 3 | POST | `/admin/auth/accounts/{id}/unlock` | `AdminOperatedByRequest` | 200 | `ADMIN_UNLOCK` |
| 4 | POST | `/admin/auth/accounts/{id}/unexpire` | `AdminOperatedByRequest` | 200 | `ADMIN_UNEXPIRE` |
| 5 | POST | `/admin/auth/accounts/{id}/disable` | `AdminStatusChangeRequest` | 200 | `ADMIN_STATUS_CHANGE` |
| 6 | POST | `/admin/auth/accounts/{id}/enable` | `AdminStatusChangeRequest` | 200 | `ADMIN_STATUS_CHANGE` |
| 7 | DELETE | `/admin/auth/accounts/{id}` | `AdminStatusChangeRequest` | 200 | `ADMIN_STATUS_CHANGE` |
| 8 | PUT | `/admin/auth/accounts/{id}/roles` | `AdminReplaceRolesRequest` | 200 | `ADMIN_REPLACE_ROLES` |

#### 6.7.2 エラーコード体系（確定）

| HTTP | code | 発生条件 |
|---:|---|---|
| 400 | `ADMIN-VAL-001` | `@Valid` のフィールドバリデーションエラー（MethodArgumentNotValidException） |
| 400 | `ADMIN-VAL-002` | ConstraintViolationException |
| 400 | `ADMIN-BIZ-002` | ロールコード不正（RoleNotFoundException） |
| 403 | `FORBIDDEN` | `ROLE_ADMIN required` |
| 409 | `ADMIN-BIZ-001` | loginId重複（DuplicateLoginIdException） |
| 500 | `INTERNAL_ERROR` | 予期しない例外 |

- エラーボディ:
  - `{ "code": "...", "message": "...", "details": ["field: reason", "..."] }`

## 7. DB/SQL 詳細設計

本章は、統合DDL（`02_db_design_ddl_integrated.md`）を正とし、運用/試験で必要となる VIEW・索引・MyBatis SQL（雛形）を確定する。  
本番DBは PostgreSQL、試験は H2 を想定し、方言差は **H2専用DDL（VIEWのみ差替）** で吸収する（D-09一次案）。

### 7.1 スキーマオブジェクト（正）

対象テーブル（抜粋）:
- AUTH_ACCOUNT（アカウント）
- AUTH_LOGIN_HISTORY（ログイン履歴）
- AUTH_PASSWORD_HISTORY（パスワード履歴）
- AUTH_ACCOUNT_LOCK_HISTORY（ロック履歴）
- AUTH_ACCOUNT_EXPIRY_HISTORY（期限履歴）
- AUTH_ACCOUNT_STATUS_HISTORY（状態変更履歴）
- AUTH_ROLE / AUTH_ACCOUNT_ROLE（ロール）

対象VIEW:
- AUTH_ACCOUNT_CURRENT_V（現在状態導出）
- AUTH_ACCOUNT_ROLE_V（アカウント→ロールコード）

> カラム定義・制約は統合DDLを正とし、本章は SQL の使用方法（参照/更新）と方言差を扱う。

### 7.2 インデックス（DDL反映要否）

統合DDLに索引DDLを含めるかは運用方針によるが、少なくとも以下は性能要件上必須となる。

| 目的 | 推奨索引（例） |
|---|---|
| login_id検索 | `AUTH_ACCOUNT(login_id)`（ユニーク）※DDLに含まれる |
| 最新ロック取得 | `AUTH_ACCOUNT_LOCK_HISTORY(auth_account_id, occurred_at DESC, auth_account_lock_history_id DESC)` |
| 最新期限取得 | `AUTH_ACCOUNT_EXPIRY_HISTORY(auth_account_id, occurred_at DESC, auth_account_expiry_history_id DESC)` |
| 最新PW取得 | `AUTH_PASSWORD_HISTORY(auth_account_id, changed_at DESC, auth_password_history_id DESC)` |
| 最新状態取得 | `AUTH_ACCOUNT_STATUS_HISTORY(auth_account_id, occurred_at DESC, auth_account_status_history_id DESC)` |
| 最新成功ログイン取得 | `AUTH_LOGIN_HISTORY(auth_account_id, login_at DESC, auth_login_history_id DESC)` |

> 「日時が同一」のケースを考慮し、タイブレークとして主キー降順を併用する。

### 7.3 VIEW（PostgreSQL：本番）

#### 7.3.1 AUTH_ACCOUNT_CURRENT_V（統合DDL準拠）

統合DDLは、最新行抽出に `LATERAL`＋`ORDER BY ... LIMIT 1` を採用している（PGで安定・可読性が高い）。

```sql
CREATE OR REPLACE VIEW AUTH_ACCOUNT_CURRENT_V AS
SELECT
    a.auth_account_id,
    a.login_id,
    a.account_status,

    COALESCE(l.locked, FALSE)                  AS locked,
    COALESCE((e.event_type = 'EXPIRE'), FALSE) AS expired,
    ll.last_login_at                           AS last_login_at
FROM AUTH_ACCOUNT a
LEFT JOIN LATERAL (
    SELECT h.locked
    FROM AUTH_ACCOUNT_LOCK_HISTORY h
    WHERE h.auth_account_id = a.auth_account_id
    ORDER BY h.occurred_at DESC, h.auth_account_lock_history_id DESC
    LIMIT 1
) l ON TRUE
LEFT JOIN LATERAL (
    SELECT h.event_type
    FROM AUTH_ACCOUNT_EXPIRY_HISTORY h
    WHERE h.auth_account_id = a.auth_account_id
    ORDER BY h.occurred_at DESC, h.auth_account_expiry_history_id DESC
    LIMIT 1
) e ON TRUE
LEFT JOIN LATERAL (
    SELECT h.login_at AS last_login_at
    FROM AUTH_LOGIN_HISTORY h
    WHERE h.auth_account_id = a.auth_account_id
      AND h.result = 'SUCCESS'
    ORDER BY h.login_at DESC, h.auth_login_history_id DESC
    LIMIT 1
) ll ON TRUE;
```

#### 7.3.2 AUTH_ACCOUNT_ROLE_V（統合DDL準拠）

```sql
CREATE OR REPLACE VIEW AUTH_ACCOUNT_ROLE_V AS
SELECT
    ar.auth_account_id,
    r.role_code
FROM AUTH_ACCOUNT_ROLE ar
JOIN AUTH_ROLE r ON r.auth_role_id = ar.auth_role_id;
```

### 7.4 H2 試験DDL（VIEW差替）（決定：D-09）

#### 7.4.1 方針
- H2用DDLは、統合DDLをベースに **VIEWのみ差替** したファイルとして管理する（例: `ddl_h2.sql`）。
- テーブル定義は統合DDLに極力合わせる（IDENTITY/BOOLEAN/TIMESTAMPはH2側の互換で吸収）
- `LATERAL` が利用できない/挙動差が出る場合、`row_number()` を用いたVIEWへ差替する

#### 7.4.2 AUTH_ACCOUNT_CURRENT_V（H2案：row_number版）

```sql
CREATE OR REPLACE VIEW AUTH_ACCOUNT_CURRENT_V AS
WITH
lock_latest AS (
  SELECT auth_account_id, locked
  FROM (
    SELECT h.*,
           row_number() over(partition by auth_account_id
                             order by occurred_at desc, auth_account_lock_history_id desc) as rn
    FROM AUTH_ACCOUNT_LOCK_HISTORY h
  ) t
  WHERE rn = 1
),
expiry_latest AS (
  SELECT auth_account_id, event_type
  FROM (
    SELECT h.*,
           row_number() over(partition by auth_account_id
                             order by occurred_at desc, auth_account_expiry_history_id desc) as rn
    FROM AUTH_ACCOUNT_EXPIRY_HISTORY h
  ) t
  WHERE rn = 1
),
last_login AS (
  SELECT auth_account_id, login_at as last_login_at
  FROM (
    SELECT h.*,
           row_number() over(partition by auth_account_id
                             order by login_at desc, auth_login_history_id desc) as rn
    FROM AUTH_LOGIN_HISTORY h
    WHERE result = 'SUCCESS'
  ) t
  WHERE rn = 1
)
SELECT
  a.auth_account_id,
  a.login_id,
  a.account_status,
  COALESCE(l.locked, FALSE) AS locked,
  COALESCE((e.event_type = 'EXPIRE'), FALSE) AS expired,
  ll.last_login_at
FROM AUTH_ACCOUNT a
LEFT JOIN lock_latest  l  ON l.auth_account_id  = a.auth_account_id
LEFT JOIN expiry_latest e  ON e.auth_account_id  = a.auth_account_id
LEFT JOIN last_login    ll ON ll.auth_account_id = a.auth_account_id;
```

> H2で `WITH`/`row_number()` のサポート状況はバージョンに依存するため、CI実行環境のH2バージョンに合わせて最終調整する。

### 7.5 MyBatis SQL（雛形：確定候補）

以降は、Mapper XML（またはアノテーション）に落とし込む際の確定候補SQLを示す。  
`created_by / operated_by` は統合DDLで **NOT NULL** のため、システム操作は `'SYSTEM'` を使用する。

#### 7.5.1 AUTH_ACCOUNT（参照）

- login_id からアカウント取得（認証時）

```sql
SELECT auth_account_id, login_id, password_hash, account_status
FROM AUTH_ACCOUNT
WHERE login_id = #{loginId};
```

- CURRENT_V 経由で状態取得（locked/expired/last_login_at）

```sql
SELECT *
FROM AUTH_ACCOUNT_CURRENT_V
WHERE auth_account_id = #{authAccountId};
```

#### 7.5.2 AUTH_LOGIN_HISTORY（insert）

```sql
INSERT INTO AUTH_LOGIN_HISTORY(auth_account_id, result, login_at, created_by)
VALUES(#{authAccountId}, #{result}, CURRENT_TIMESTAMP, 'SYSTEM');
```

#### 7.5.3 連続FAILURE数の算出（上限付き）

上限N件（例：20）を新しい順に取得し、SUCCESSが現れるまでのFAILURE件数をアプリ側でカウントする方式を基本とする。

```sql
SELECT result
FROM AUTH_LOGIN_HISTORY
WHERE auth_account_id = #{authAccountId}
ORDER BY login_at DESC, auth_login_history_id DESC
LIMIT #{limitN};
```

> LIMITの利用可否はDB方言差があるため、H2側では `FETCH FIRST #{limitN} ROWS ONLY` 等へ差替する（方言吸収はMapperで対応）。

#### 7.5.4 ロック最新取得

```sql
SELECT locked, occurred_at
FROM AUTH_ACCOUNT_LOCK_HISTORY
WHERE auth_account_id = #{authAccountId}
ORDER BY occurred_at DESC, auth_account_lock_history_id DESC
LIMIT 1;
```

#### 7.5.5 ロック登録（冪等）

- 最新が locked=true の場合は insert しない。
- insertする場合は reason/operated_by/created_by を必須で設定する。

```sql
INSERT INTO AUTH_ACCOUNT_LOCK_HISTORY(auth_account_id, locked, reason, occurred_at, operated_by, created_by)
-- ※統合DDLのカラム名（reason/created_by 等）に合わせて最終調整する
VALUES(#{authAccountId}, TRUE, 'FAILURE_THRESHOLD', CURRENT_TIMESTAMP, 'SYSTEM', 'SYSTEM');
```

#### 7.5.6 期限最新取得

```sql
SELECT event_type, occurred_at
FROM AUTH_ACCOUNT_EXPIRY_HISTORY
WHERE auth_account_id = #{authAccountId}
ORDER BY occurred_at DESC, auth_account_expiry_history_id DESC
LIMIT 1;
```

#### 7.5.7 EXPIRE/UNEXPIRE 登録

```sql
-- EXPIRE（冪等。最新がEXPIREなら省略）
INSERT INTO AUTH_ACCOUNT_EXPIRY_HISTORY(auth_account_id, event_type, reason, occurred_at, operated_by, created_by)
VALUES(#{authAccountId}, 'EXPIRE', 'PASSWORD_EXPIRED', CURRENT_TIMESTAMP, 'SYSTEM', 'SYSTEM');

-- UNEXPIRE（本人変更/管理者リセットで使用。最新がUNEXPIREなら省略可）
INSERT INTO AUTH_ACCOUNT_EXPIRY_HISTORY(auth_account_id, event_type, reason, occurred_at, operated_by, created_by)
VALUES(#{authAccountId}, 'UNEXPIRE', #{reason}, CURRENT_TIMESTAMP, #{operatedBy}, #{operatedBy});
```

#### 7.5.8 AUTH_PASSWORD_HISTORY（直近3世代取得）

```sql
SELECT password_hash, changed_at
FROM AUTH_PASSWORD_HISTORY
WHERE auth_account_id = #{authAccountId}
ORDER BY changed_at DESC, auth_password_history_id DESC
LIMIT #{historyCount}; -- 既定3
```

#### 7.5.9 AUTH_ACCOUNT 更新（PW/状態）

- パスワード更新（楽観ロック version を利用する場合）

```sql
UPDATE AUTH_ACCOUNT
SET password_hash = #{passwordHash},
    updated_at    = CURRENT_TIMESTAMP,
    updated_by    = #{updatedBy},
    version       = version + 1
WHERE auth_account_id = #{authAccountId}
  AND version = #{version};
```

- account_status 更新（状態変更）

```sql
UPDATE AUTH_ACCOUNT
SET account_status = #{toStatus},
    updated_at     = CURRENT_TIMESTAMP,
    updated_by     = #{updatedBy},
    version        = version + 1
WHERE auth_account_id = #{authAccountId}
  AND version = #{version};
```

> 0件更新の場合は `ConflictException` とし、業務側へ競合を通知する。

#### 7.5.10 AUTH_ACCOUNT_STATUS_HISTORY（insert）

```sql
INSERT INTO AUTH_ACCOUNT_STATUS_HISTORY(auth_account_id, from_status, to_status, reason, occurred_at, operated_by, created_by)
VALUES(#{authAccountId}, #{fromStatus}, #{toStatus}, #{reason}, CURRENT_TIMESTAMP, #{operatedBy}, #{operatedBy});
```

#### 7.5.11 AUTH_ACCOUNT_ROLE / AUTH_ROLE（ロール）

- role_code → auth_role_id 解決

```sql
SELECT auth_role_id
FROM AUTH_ROLE
WHERE role_code = #{roleCode}
  AND enabled = TRUE;
```

- 付与（重複はユニーク制約で検知してよい）

```sql
INSERT INTO AUTH_ACCOUNT_ROLE(auth_account_id, auth_role_id, created_by)
VALUES(#{authAccountId}, #{authRoleId}, #{createdBy});
```

- 剥奪

```sql
DELETE FROM AUTH_ACCOUNT_ROLE
WHERE auth_account_id = #{authAccountId}
  AND auth_role_id = #{authRoleId};
```

---

## 8. 監査ログ 詳細設計

本章は、基本設計 9章を前提に、監査ログの出力フォーマット、loginId（NOT_FOUND）の加工方式（HMAC/Mask）、実装責務を確定する。

### 8.1 出力フォーマット

- 形式: JSON（1イベント=1行）
- 文字コード: UTF-8
- 出力: アプリケーションログ（INFO）
- ロガー名: `audit`（監査ログ専用Loggerを分離推奨）
- MDC: `correlationId` を必ず含める（CorrelationIdFilter）

### 8.2 JSONスキーマ（確定候補）

#### 8.2.1 監査イベント一覧（確定）

| event | 主な必須項目 | 備考 |
|---|---|---|
| LOGIN_SUCCESS | authAccountId | D-02により出力可否は運用で制御 |
| LOGIN_FAILURE | authAccountId, reason | reasonは内部コード（FAILURE等） |
| LOGIN_ATTEMPT_NOT_FOUND | loginId(hmac) | D-03 |
| PASSWORD_CHANGED | authAccountId | 本人変更完了 |
| ADMIN_CREATE_ACCOUNT | authAccountId, loginId(hmac), roleCodes, operatedBy(loginId) | loginIdはHMAC化 |
| ADMIN_RESET_PASSWORD | authAccountId, operatedBy(loginId) | 初期化 |
| ADMIN_UNLOCK | authAccountId, operatedBy(loginId) | ロック解除 |
| ADMIN_UNEXPIRE | authAccountId, operatedBy(loginId) | 期限解除 |
| ADMIN_STATUS_CHANGE | authAccountId, fromStatus, toStatus, reason, operatedBy(loginId) | 無効/有効/削除 |
| ADMIN_REPLACE_ROLES | authAccountId, roleCodes, operatedBy(loginId) | ロール置換 |

共通項目（必須）:
- occurredAt（ISO8601）
- event
- correlationId
- ip
- userAgent（任意）

追加項目（イベント別）:
- authAccountId（存在する場合）
- operatedBy（管理者操作必須）
- result / reason
- loginId（NOT_FOUND時のみ必須：加工後の値）

例（LOGIN_FAILURE）:
```json
{
  "occurredAt": "2026-01-25T10:00:00Z",
  "event": "LOGIN_FAILURE",
  "correlationId": "0b51...",
  "ip": "203.0.113.10",
  "userAgent": "Mozilla/5.0 ...",
  "authAccountId": 1001,
  "result": "FAILURE",
  "reason": "FAILURE"
}
```

例（LOGIN_ATTEMPT_NOT_FOUND）:
```json
{
  "occurredAt": "2026-01-25T10:00:00Z",
  "event": "LOGIN_ATTEMPT_NOT_FOUND",
  "correlationId": "0b51...",
  "ip": "203.0.113.10",
  "userAgent": "Mozilla/5.0 ...",
  "loginId": "hmac:1f0a9c..."
}
```

### 8.3 loginId加工方式（NOT_FOUND）

詳細設計として **HMAC（hex）方式を採用**する（決定：D-03）。運用上、必要となる場合のみ `mask` を代替案として採用可（変更管理対象）。

#### 8.3.1 HMAC方式（推奨）

- アルゴリズム: HmacSHA256
- 出力: `hmac:` + hex（またはbase64url） ※本プロジェクトは **hex** を採用
- 出力は `hmac:` プレフィックス + 64桁hex（SHA-256=32byte）とする。

- 秘密鍵: `auth.audit.loginId.hmac-secret`（Secrets管理）

疑似コード（Java）:
```java
public class LoginIdHasher {
  public String hmacHex(String secret, String input) {
    Mac mac = Mac.getInstance("HmacSHA256");
    mac.init(new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256"));
    byte[] out = mac.doFinal(input.getBytes(StandardCharsets.UTF_8));
    return "hmac:" + HexFormat.of().formatHex(out);
  }
}
```

- ローテーション: 運用設計で決定（年次等）
- 相関性: 同一入力は同一出力となり、ID列挙攻撃の検知（同一loginIdの繰り返し）に利用できる

#### 8.3.2 Mask方式（代替）

- 例: `ab****yz`（prefix/suffix長は設定値）
- 文字数が短い場合は全マスク（例: `****`）

### 8.4 IP取得（ForwardedHeader）（決定：D-05）

- `auth.web.forwarded-header.enabled=true` の場合、`ForwardedHeaderFilter` を有効にする。
- 監査ログの `ip` は `HttpServletRequest#getRemoteAddr()` を基本とし、ForwardedHeaderが有効なら解釈後の値を採用する。

### 8.5 実装責務

| 箇所 | 出力イベント |
|---|---|
| FailureHandler | LOGIN_ATTEMPT_NOT_FOUND（NOT_FOUND時のみ最小出力） |
| LoginProcessSharedService | LOGIN_FAILURE / LOGIN_SUCCESS（設定により）、EXPIRE等の付帯処理 |
| PasswordChangeSharedService | PASSWORD_CHANGE |
| AuthAccountAdminSharedService | ADMIN_* / ROLE_* |

> NOT_FOUND の loginId加工は FailureHandler か専用AuditServiceで行い、必ずSecretsから鍵を取得する。



## 9. 設定定義（環境差分表）

本章は、設定項目（基本設計 10章）について、環境別の設定値（案）を整理し、詳細設計の確定版とする。  
機微情報は Secrets 管理とし、本表では「存在/管理方式」のみ示す。

### 9.1 環境別設定（案）

| キー | DEV | IT | PROD | 備考 |
|---|---|---|---|---|
| auth.post-login-success-url | `/menu`（仮） | `/menu`（仮） | `/menu`（仮） | **決定（D-01）：環境毎に必須設定** |
| auth.audit.success.enabled | false | false | false | **決定（D-02）：既定false。必要時のみ変更管理でtrue** |
| auth.audit.loginId.mode | hmac | hmac | hmac | **決定（D-03）：HMAC（hex）** |
| auth.audit.loginId.hmac-secret | Secrets（ダミー） | Secrets | Secrets | DEVはダミー鍵でも可 |
| auth.web.forwarded-header.enabled | false | true | true | **決定（D-05）：LB配下はtrue** |
| auth.web.correlation-id.header | X-Correlation-Id | X-Correlation-Id | X-Correlation-Id | **決定（D-06）** |
| auth.web.correlation-id.generate-if-absent | true | true | true | **決定（D-06）** |
| auth.password.encoder | bcrypt | bcrypt | bcrypt | |
| auth.password.encoder.bcrypt-strength | 10 | 10 | 10 | **決定（D-07）：初期値10。性能試験で変更する場合は変更管理** |
| server.servlet.session.timeout | 30m | 30m | 30m | |
| auth.session.absolute-timeout-hours | 12 | 12 | 12 | |
| auth.session.max-sessions | 1 | 1 | 1 | |

### 9.2 Secrets管理（方針）

- 対象
  - auth.initial-password-hash
  - auth.audit.loginId.hmac-secret
- 管理
  - 環境毎に異なる値を払い出し、アクセス権限は運用最小権限とする
  - ローテーションは **年次** を基本とする（決定：D-04）。変更時はアプリ再起動（または動的リロード）を運用で定義する



## 10. 変更履歴

| 版数 | 日付 | 変更内容 | 作成者 |
|---|---|---|---|
| 0.1 | 2026-01-25 | 初版ドラフト（決定事項一次案＋詳細設計の骨格作成） | ChatGPT |
| 0.2 | 2026-01-25 | Spring Security詳細（Filter/Handler/例外マッピング/NOT_FOUND隠蔽）を具体化 | ChatGPT |
| 0.3 | 2026-01-25 | SharedService詳細（Tx/認可/冪等/履歴insert順序/例外）を具体化 | ChatGPT |
| 0.4 | 2026-01-25 | DB/SQL詳細（統合DDL準拠、H2 VIEW差替、MyBatis SQL雛形、NOT NULL制約反映）を具体化 | ChatGPT |
| 0.5 | 2026-01-25 | 監査ログ詳細（HMAC方式/スキーマ/責務）と環境差分表（Secrets方針）を確定候補化 | ChatGPT |
| 0.6 | 2026-01-25 | 決定事項の決定管理（状態/責任/期限/影響）と付録（合意記録/レビュー観点）を追加 | ChatGPT |
| 0.6.1 | 2026-01-25 | D-06（相関ID運用）とD-09（H2互換VIEW）を決定し本文/設定/合意記録へ反映 | ChatGPT |
| 0.6.2 | 2026-01-25 | D-01（業務メニューURL）とD-08（絶対タイムアウトUX）を決定し本文/画面/設定/合意記録へ反映 | ChatGPT |
| 0.6.3 | 2026-01-25 | D-03（NOT_FOUND loginId方式：HMAC）とD-07（bcrypt強度=10）を決定し監査ログ/設定/合意記録へ反映 | ChatGPT |
| 0.6.4 | 2026-01-25 | D-02/D-04/D-05/D-10 を決定し、認可/ForwardedHeader/監査ログ出力/鍵ローテ方針を本文・設定・合意記録へ反映 | ChatGPT |
| 0.7 | 2026-01-25 | レビュー投入版：決定事項反映完了、文言/メッセージ/用語の整合を実施 | ChatGPT |

---

## 11. 承認

| 区分 | 氏名 | 日付 | 備考 |
|---|---|---|---|
| 作成 |  |  |  |
| レビュー |  |  |  |
| 承認 |  |  |  |


---

## 12. 付録A：決定事項の合意記録

| ID | 決定内容 | 合意者 | 日付 | 備考 |
|---|---|---|---|---|
|  |  |  |  |  |

---

## 13. 付録B：レビュー観点（チェックリスト）

- セキュリティ
  - NOT_FOUND隠蔽（例外差分が外部に漏れない）
  - パスワードポリシー（許可記号/最小長/世代数）が要件通り
  - 監査ログに平文PWが混入しない（厳禁）
  - HMAC秘密鍵の管理・権限・ローテーション手順がある
- 可用性/運用
  - 監査ログ量（LOGIN_SUCCESS含む）と保管/検索コスト
  - ログ相関（correlationId）で追跡できる
- 性能
  - bcrypt strength の妥当性（認証TPS）
  - 最新行取得（VIEW/索引）がボトルネックにならない
- 試験容易性
  - H2互換DDL（VIEW差替）でUTが安定して回る
  - 例外マッピングがテストで再現可能
- DDD/責務分離
  - Domainルール（ロック/期限/ポリシー）がApplicationへ漏れすぎていない
  - SharedServiceがI/F境界として一貫している（業務側DB直参照を誘発しない）

## 9. 設定値一覧（プロパティ）

本章に認証基盤のプロパティを集約する。**Domain層はSpring非依存**であり、プロパティ読込とBean生成は boot層で実施する（9.1）。

### 9.1 レイヤ方針（Domain層のSpring非依存）

- Domain層から `org.springframework.*` への依存を排除する（@Component/@Value等を使用しない）。
- 設定値注入・Bean生成は boot層（設定/配線）で実施し、Domainは純粋Javaとして実装する。
- Domain例外を定義し、Application層で画面/メッセージ向け例外へ変換する。

### 9.2 プロパティ一覧（確定）

| Key | 必須 | 既定 | 用途/備考 |
|---|---|---|---|
| auth.post-login-success-url | Yes | - | ログイン成功後の業務メニューURL（環境別） |
| auth.session.max-sessions | No | 1 | 同時ログイン制御（U-07 推奨方針） |
| auth.session.absolute-timeout-hours | No | 12 | 絶対タイムアウト（D-08） |
| auth.web.forwarded-header.enabled | No | false | LB配下でtrue（D-05） |
| auth.web.correlation-id.header | No | X-Correlation-Id | 相関IDヘッダ名（D-06） |
| auth.web.correlation-id.generate-if-absent | No | true | ヘッダが無い場合に生成 |
| auth.initial-password-hash | Yes | - | 初期パスワード（bcrypt hash、U-09） |
| auth.password.history-count | No | 3 | 過去N世代一致禁止 |
| auth.password.min-length | No | 12 | PasswordPolicy |
| auth.password.max-length | No | 64 | PasswordPolicy |
| auth.password.require-alpha | No | true | 英字必須 |
| auth.password.require-digit | No | true | 数字必須 |
| auth.password.prohibit-include-login-id | No | true | loginId含有禁止 |
| auth.password.prohibit-seq-length | No | 3 | 連番禁止（単調増加/減少） |
| auth.password.prohibit-repeat-length | No | 4 | 同一文字連続禁止 |
| auth.audit.loginId.hmac-secret | Yes(Prod) | - | loginId HMAC秘密鍵（D-04）。Secretsで管理 |
| auth.audit.login-success.enabled | No | false | LOGIN_SUCCESS監査ログ出力（D-02） |

- 備考:
  - `auth.audit.loginId.hmac-secret` は環境変数/Secrets等で注入し、設定ファイルへ平文を置かない。
  - 初期PW運用（U-09）の平文値はアプリに保持しない。

### 9.3 環境別設定指針（Dev/IT/Prod）

本章では、運用上「必須」「推奨」「非推奨」となる設定値を環境別に整理する。

#### 9.3.1 Dev（開発環境）
- 目的: 開発者の利便性と迅速な検証
- 推奨:
  - `auth.audit.login-success.enabled=false`（ログ量抑制）
  - `auth.web.correlation-id.generate-if-absent=true`
- 注意:
  - `auth.audit.loginId.hmac-secret` は **Devでも設定推奨**（監査ログの形式検証のため）。
    - 未設定時はログ上 `UNCONFIGURED` となり、監査要件の検証ができない。

#### 9.3.2 IT/ST（結合・総合試験環境）
- 目的: 本番相当の運用/監査/障害解析を検証
- 推奨:
  - `auth.audit.loginId.hmac-secret` を本番相当の方法（Secrets/環境変数）で注入
  - `auth.session.max-sessions=1`（U-07 推奨方針）
  - `auth.session.absolute-timeout-hours` を要件値に合わせる（D-08）

#### 9.3.3 Prod（本番環境）
- 目的: 監査・セキュリティ・可用性の最大化
- 必須:
  - `auth.audit.loginId.hmac-secret`（Secretsで管理。設定ファイルへ平文を置かない）
  - `auth.initial-password-hash`（平文値は保持しない）
- 推奨:
  - `auth.audit.login-success.enabled` は監査要件次第（通常は false、必要時のみ true）
  - `auth.web.forwarded-header.enabled=true`（LB配下）

## 10. テスト設計（UT観点）

本章は、UT（単体テスト）で担保すべき観点を整理する。業務チームが本基盤を利用する際の受入観点（IT）にも転用できるよう、**入力・状態・DB履歴・監査ログ**を一貫して確認する。

### 10.1 テスト共通方針
- DB: UTはH2（互換VIEW方針 D-09）を基本。SQL互換差分はH2用DDLで吸収する。
- 監査ログ: logger名 `audit` を対象にテストで捕捉可能とする（Appender差替等）。
- 相関ID: `auth.web.correlation-id.header` を付与しない場合も `generate-if-absent=true` で必ず出力されること。

### 10.2 PasswordChange（本人変更）

| No | 観点 | 入力/前提 | 期待結果 |
|---:|---|---|---|
| PWD-01 | 現在PW不一致 | currentPassword誤り | `MSG-PWD-ERR-001`（InvalidCurrentPassword） |
| PWD-02 | 確認不一致 | new != confirm | `MSG-PWD-ERR-003` |
| PWD-03 | 長さ不足 | len < min | `MSG-PWD-ERR-002`（policy） |
| PWD-04 | 長さ超過 | len > max | `MSG-PWD-ERR-002` |
| PWD-05 | 禁止文字 | 空白/非printable混入 | `MSG-PWD-ERR-002` |
| PWD-06 | 英字必須 | digitのみ | `MSG-PWD-ERR-002` |
| PWD-07 | 数字必須 | alphaのみ | `MSG-PWD-ERR-002` |
| PWD-08 | loginId含有禁止 | new に loginId相当を含む | `MSG-PWD-ERR-002` |
| PWD-09 | 連番禁止 | `abc` / `123` 等を含む | `MSG-PWD-ERR-002` |
| PWD-10 | 連続禁止 | 同一4連続 | `MSG-PWD-ERR-002` |
| PWD-11 | 履歴一致禁止 | 過去N世代と一致 | `MSG-PWD-ERR-002`（reused） |
| PWD-12 | 正常 | 全条件満たす | password_hash更新、history追加、UNEXPIRE追加、監査 `PASSWORD_CHANGED` |

### 10.3 管理者API（AdminAuthAccountController）

| No | 観点 | 入力/前提 | 期待結果 |
|---:|---|---|---|
| ADM-01 | 認可NG | ROLE_ADMINなし | 403 `FORBIDDEN` |
| ADM-02 | create validation | loginId空 / roleCodes空 | 400 `ADMIN-VAL-001` |
| ADM-03 | create duplicate | loginId既存 | 409 `ADMIN-BIZ-001` |
| ADM-04 | create role不正 | roleCodesに不存在 | 400 `ADMIN-BIZ-002` |
| ADM-05 | create 正常 | loginId新規、role正常 | AUTH_ACCOUNT/ROLE/HISTORY/EXPIRE追加、監査 `ADMIN_CREATE_ACCOUNT` |
| ADM-06 | reset 正常 | 既存ID | password_hash初期化、HISTORY(ADMIN_RESET)、EXPIRE付与、監査 `ADMIN_RESET_PASSWORD` |
| ADM-07 | unlock 正常 | locked=true前提 | LOCK_HISTORYにlocked=false追加、監査 `ADMIN_UNLOCK` |
| ADM-08 | unexpire 正常 | expired=true前提 | EXPIRY_HISTORYにUNEXPIRE追加、監査 `ADMIN_UNEXPIRE` |
| ADM-09 | status change | disable/enable/delete | status更新、STATUS_HISTORY追加、監査 `ADMIN_STATUS_CHANGE` |
| ADM-10 | roles replace | 置換 | ROLE全削除→再付与、監査 `ADMIN_REPLACE_ROLES` |

### 10.4 ログイン（LoginSharedService / FilterChain）

| No | 観点 | 入力/前提 | 期待結果 |
|---:|---|---|---|
| L-01 | 成功 | 正しいloginId/PW | 業務メニューへリダイレクト、必要に応じ監査 `LOGIN_SUCCESS` |
| L-02 | 失敗（存在） | 誤PW | 失敗画面遷移（U-02 A）、FAILURE履歴/ロック判定、監査 `LOGIN_FAILURE` |
| L-03 | 失敗（不存在） | 不存在loginId | NOT_FOUND方針（D-03）で秘匿、監査 `LOGIN_ATTEMPT_NOT_FOUND`（loginIdはHMAC） |
| L-04 | ロック | 閾値超過 | locked=true判定、失敗画面、監査（必要なら） |
| L-05 | 期限切れ | expired=true | パスワード変更画面誘導、イベント発生契機はログイン時（U-06 B） |
| L-06 | 同時ログイン | max-sessions=1 | 2セッション目の扱いが推奨方針通りであること（U-07） |
| L-07 | 絶対タイムアウト | 期限超過 | UX方針（D-08）に従い再ログイン誘導 |

## 11. 運用設計（設定値管理）

本章は、設定値（プロパティ）の**管理主体・保管方法・変更手順・監査観点**を確定する。

### 11.1 管理主体（RACI）

| 区分 | 例 | 変更権限 | 管理主体 | 備考 |
|---|---|---|---|---|
| Secrets（機密） | `auth.audit.loginId.hmac-secret` | 限定 | 運用/基盤 | Secrets Manager / K8s Secret等で管理 |
| アプリ設定（環境別） | `auth.post-login-success-url` | 通常 | 運用/業務 | 環境ごとに異なる |
| セキュリティ設定 | `auth.session.max-sessions`, `auth.session.absolute-timeout-hours` | 通常 | 運用/基盤 | 監査要件により固定化されやすい |
| パスワードポリシー | `auth.password.*` | 変更は慎重 | 基盤（承認付き） | 変更時は利用者周知/リグレッション試験必須 |
| 初期PWハッシュ | `auth.initial-password-hash` | 限定 | 運用/基盤 | 平文は保持しない。変更は運用手順に従う |

### 11.2 Secretsの取り扱い（必須）

- `auth.audit.loginId.hmac-secret`
  - **必須（本番）**
  - 設定ファイル（Git/イメージ）へ平文を置かない
  - 変更（ローテーション）時の留意点:
    - 変更後の監査ログでは loginId のHMAC値が変わる（同一loginIdでも一致しない）
    - ログ解析基盤側で「キー変更日」を境に突合ロジックを分けるか、旧キーも一定期間保持して再計算できる仕組みを検討する

- `auth.initial-password-hash`
  - 平文初期PWは保持しない
  - 初期PWを変更する場合:
    1. 新しい平文初期PWを運用で決定
    2. bcryptでハッシュ化（所定コスト）
    3. `auth.initial-password-hash` を更新
    4. 以降の新規登録/初期化は新ハッシュが適用される

### 11.3 変更管理（リリース手順）

- `auth.password.*` を変更する場合:
  - 影響: 変更後は「従来許容されていたパスワード」が不許可となる可能性がある
  - 必須作業:
    - 変更内容のユーザ影響説明（運用マニュアル/FAQ更新）
    - UT/ITのリグレッション（第10章の観点）
    - 監査ログの確認（`PASSWORD_CHANGED` を含む）

- `auth.session.*` を変更する場合:
  - 影響: セッション破棄・再ログインの発生頻度が変化する
  - 必須作業:
    - UX（D-08）に影響しないか確認
    - 業務チームへ周知（業務画面でのリトライ導線）

### 11.4 監査ログの運用（実務観点）

- logger名: `audit`
- 出力形式: JSON（第8章）
- 収集: stdout→ログ基盤（CloudWatch/EFK/Loki等）を想定
- PII取り扱い:
  - loginId はHMAC化（生値出力禁止）
  - reason 等にユーザ入力をそのまま入れない（運用理由は定型化する）

## 12. UT実装ひな形（テスト基盤）

本章は、実装プロジェクトでUTを立ち上げるための最小ひな形を示す。

### 12.1 監査ログ（audit logger）の捕捉

- Logbackの `ListAppender` を利用して logger名 `audit` を捕捉する。
- 例: `AuditLogCapture`（Artifacts v12に追加）

確認例（擬似）:
- `PASSWORD_CHANGED` 実行後、auditログに `event:"PASSWORD_CHANGED"` が含まれること
- `LOGIN_ATTEMPT_NOT_FOUND` の loginId は `"hmac:"` で始まり、平文が出ないこと

### 12.2 H2互換DDL（VIEW）

- PostgreSQLの `DISTINCT ON` をH2はサポートしないため、H2用VIEWは `ROW_NUMBER()` で代替する。
- 例: `schema-auth-h2.sql`（Artifacts v12に追加）
  - `AUTH_ACCOUNT_CURRENT_V` を window function で最新イベント参照に置換

### 12.3 推奨テスト構成

- Service/UseCase単体:
  - MockitoでRepositoryをモックし、例外/呼び出し/監査ログ出力を確認（高速）
- Repository/SQL単体:
  - `@MybatisTest` + H2 で SQL/VIEWS を検証（D-09）
- Web層:
  - `@SpringBootTest(webEnvironment=RANDOM_PORT)` でFilterChain/認可/Validationを確認（必要範囲のみ）

### 12.4 最低限の回帰ポイント

- PasswordPolicy変更（`auth.password.*`）後:
  - 第10章 10.2 の PWD-03〜PWD-12 を再実施
- 監査ログ変更後:
  - 第8章の JSONスキーマと 8.2.1 イベント一覧に整合すること

## 13. レビュー観点チェックリスト（未決・要注意）

本章は、確定版（v1.1/1.0確定）へ向けてレビュー者が確認すべき観点を一覧化する。
「未決」と記載の項目は、業務チーム/運用/基盤の合意が必要。

### 13.1 業務チーム依存（URL/画面遷移/UX）

- [ ] **ログイン成功時遷移先URL**（`auth.post-login-success-url`）
  - 環境別URL（IT/Prod）を確定し、業務側のルーティングと一致していること
- [ ] **絶対タイムアウト時のUX**（D-08）
  - 画面メッセージ文言・遷移先（ログイン画面/業務トップ）を業務側と合意
- [ ] **パスワード変更完了画面の遷移先**
  - メニューURLへ戻すのか、ログイン画面へ戻すのか（セッション再生成方針と整合）

### 13.2 運用依存（初期PW通知/初期化/監査）

- [ ] **初期PW通知の具体手段**（U-09）
  - 通知経路（メール/チケット/電話等）、証跡の取り方（監査対応）
- [ ] **初期PWの変更（ローテーション）要否**
  - 変更頻度・作業責任者・bcryptコストの運用手順（第11章と整合）
- [ ] **監査ログの保管期間・検索要件**
  - SIEM/ログ基盤側のインデックス項目（correlationId, authAccountId, event）を確定
- [ ] **HMACキーのローテーション方針**（`auth.audit.loginId.hmac-secret`）
  - キー変更時に同一loginIdの突合ができなくなる前提で運用設計があること（第11章 11.2）

### 13.3 セキュリティ・認可（Role/制約/例外）

- [ ] **管理者権限ロール名の最終確定**（D-10）
  - `ROLE_ADMIN` と業務側の権限モデルの整合
- [ ] **管理者操作の監査項目**（operatedBy の値）
  - operatedBy を「操作者loginId」か「操作者authAccountId」か確定
  - 監査ログに残す識別子の方針（PII/匿名化）
- [ ] **ログイン成功監査ログの出力要否**（D-02）
  - 通常はfalse推奨だが、監査要件により true の可能性あり
- [ ] **パスワードポリシーのユーザ周知文言**
  - 画面の説明文（長さ/文字種/禁止ルール）とポリシー実装が一致していること

### 13.4 DB・データ整合（履歴/冪等/性能）

- [ ] **履歴テーブルの冪等性**（EXPIRE/UNEXPIRE/UNLOCK）
  - 同一操作が繰り返されても整合が崩れない（insert-only + VIEWで最新参照）
- [ ] **AUTH_ACCOUNT_CURRENT_V の性能検証**
  - ログイン高頻度時にVIEW参照がボトルネックにならないこと（必要なら索引/マテビュー等）
- [ ] **H2互換VIEWの差分管理**（D-09）
  - 本番(PostgreSQL)とUT(H2)でVIEW定義がズレないよう、DDL管理方法を確定（schema分岐）

### 13.5 テスト・リリース（回帰ポイント）

- [ ] **第10章 UT観点の網羅性**（PWD/ADM/Login）
  - 例外コード、監査イベント、DB履歴の確認が揃っていること
- [ ] **パスワードポリシー変更時の回帰手順**（第11章 11.3）
  - 変更時に必ず実施する回帰範囲を運用と合意
- [ ] **監査ログ形式変更時の影響**
  - ログ基盤側のパーサ/ダッシュボードが壊れないこと（互換性）

### 13.6 未決事項まとめ（確定が必要）

- [ ] operatedBy の内容（ID種別）を確定
- [ ] ログイン成功監査ログ（LOGIN_SUCCESS）の要否を確定
- [ ] 絶対タイムアウト時のUX（遷移先/文言）を確定
- [ ] HMACキーのローテーション運用を確定

## 14. 未決事項の確定（v1.1）

本章では、第13章「レビュー観点チェックリスト」の未決事項をv1.1で確定した内容を記載する。

### 14.1 operatedBy（管理者操作の操作者識別子）

- **確定**: `operatedBy` は **操作者の loginId（= 現状 user_id）** を文字列で出力する。
- 理由:
  - 運用・監査の一次対応（人手での照会）において、操作者を即時に識別できることを優先する。
- セキュリティ留意:
  - loginId はPIIに該当し得るため、監査ログの閲覧権限・保管期間・転送先（SIEM等）を運用設計で統制する（第11章）。
- 実装指針:
  - SecurityContext/Principal から操作者の `loginId` を取得し、`operatedBy` に設定する。
  - 対象アカウントの識別子（`authAccountId`）とは別に、`operatedBy`（操作者loginId）を出力する。

### 14.2 LOGIN_SUCCESS（ログイン成功監査ログ）

- **確定**: 既定では **出力しない（false）**。監査要件がある場合のみプロパティで有効化する。
- 設定:
  - `auth.audit.login-success.enabled=false`（default）
- 理由:
  - ログイン成功は高頻度となり、監査ログ量・保管/検索コストが支配的になるため。
  - 監査上必要な場合は明示的に有効化する。

### 14.3 絶対タイムアウト時のUX（D-08）

- **確定**: 絶対タイムアウト検知時は、セッションを破棄し **ログイン画面へリダイレクト**する。
- 画面文言（例）:
  - 「セッションの有効期限が切れました。お手数ですが再度ログインしてください。」
- メッセージID（追加）:
  - `MSG-SES-ERR-001` : セッション期限切れ（絶対タイムアウト）
- リダイレクト先:
  - `/login?reason=timeout`（表示制御はログイン画面で行う）

### 14.4 HMACキーのローテーション運用（auth.audit.loginId.hmac-secret）

- **確定**: ローテーションは原則「必要時のみ」。実施する場合は運用上の突合影響を許容する。
- 影響:
  - 同一loginIdでもHMAC値が変わるため、キー変更を跨いだ期間でログ突合ができない。
- 運用指針:
  - キー変更日を運用記録し、ログ解析時は「キー変更日」で期間を分割して扱う。
  - ローテーション頻度は最小化する（四半期/年次等の定期ローテは非推奨）。

### 14.5 H2互換VIEW差分管理（D-09）

- **確定**: 本番DDL（PostgreSQL）とUT（H2）で **DDLを分離**して管理する。
- 管理方法:
  - PostgreSQL: `db/postgresql/schema-*.sql`（本番用）
  - H2: `infrastructure/src/test/resources/db/h2/schema-auth-h2.sql`（UT用）
- 目的:
  - PostgreSQLの `DISTINCT ON` 等、方言差分をUTで吸収しつつ、仕様（列・意味）の一致を担保する。
